<!DOCTYPE html>
<html lang="en">
{% load staticfiles %}
<head>
    <meta charset="utf-8" />
    <title>Leaflet visualization</title>
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.css" />
    <link rel="stylesheet" href="{% static 'routeapp/css/graph-style.css' %}" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    
    <script src="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js" charset="utf-8"></script>
    <link rel="stylesheet" href="{% static 'routeapp/leaflet.awesome-markers.css' %}">
    <script src="{% static 'routeapp/leaflet.awesome-markers.js' %}"></script>
    
    <script language="javascript">
    
    var MarkerIcon = L.Icon.extend({
    options: {
        shadowUrl: "{% static 'routeapp/marker-shadow.png' %}",
        iconSize:     [38, 95],
        shadowSize:   [50, 64],
        iconAnchor:   [144, 467],
        shadowAnchor: [144, 467],
        popupAnchor:  [-3, -76]
    }
});
var greenIcon = new MarkerIcon({iconUrl: "{% static 'routeapp/marker-green.png' %}"}),
    redIcon = new MarkerIcon({iconUrl: "{% static 'routeapp/marker-red.png' %}"});
    var startIcon = L.AwesomeMarkers.icon({
        prefix: 'fa', //font awesome rather than bootstrap
        markerColor: 'green', // see colors above
        icon: 'home' //http://fortawesome.github.io/Font-Awesome/icons/
    });
    var endIcon = L.AwesomeMarkers.icon({
        prefix: 'fa', //font awesome rather than bootstrap
        markerColor: 'red', // see colors above
        icon: 'flag-checkered' //http://fortawesome.github.io/Font-Awesome/icons/
    });
    var pinIcon = L.AwesomeMarkers.icon({
        prefix: 'fa', //font awesome rather than bootstrap
        markerColor: 'blue', // see colors above
        icon: 'map-pin' //http://fortawesome.github.io/Font-Awesome/icons/
    });
    </script>
    
    <style type="text/css">
        #map {
            position: relative;
            height: 70%;
        }
        
        #elevation-graph {
            position: relative;
            height: 30%;
            width: 90%;
            top: -100pz;
            left: 100px;
        }
        
        html,
        body {
            height: 100%;
            margin: 0px;
            padding: 0px;
        }
		
		#panel {
        position: absolute;
        top: 5px;
        left: 50%;
        margin-left: -180px;
        z-index: 5;
        background-color: #fff;
        padding: 5px;
        border: 1px solid #999;
      }

      /*
      Provide the following styles for both ID and class,
      where ID represents an actual existing "panel" with
      JS bound to its name, and the class is just non-map
      content that may already have a different ID with
      JS bound to its name.
      */

      #panel, .panel {
        font-family: 'Roboto','sans-serif';
        line-height: 30px;
        padding-left: 10px;
      }

      #panel select, #panel input, .panel select, .panel input {
        font-size: 15px;
      }

      #panel select, .panel select {
        width: 100%;
      }

      #panel i, .panel i {
        font-size: 12px;
      }
    </style>
	<script src="{% static 'routeapp/js/leaflet-knn.min.js' %}"></script>
</head>

<body>

    <div id="map"></div>
    <!--<script src="/getroute/route.geojson"></script>-->
    <script language="javascript">
    var freeBus = {{ routegeojson|safe }};
    </script>
    <script language="javascript">
    var jsondata = '{{elevationjson|safe}}';
    </script>
	<div id="elevation-graph">
        <!--<script src="{% static 'routeapp/js/elevation-graph.js' %}"></script>-->
        <script language="javascript">
            var svg;
var linesvg;
var xScale;
var yScale;
var json = JSON.parse(jsondata);


        //Retrieve array of elevation info from json file
        var elevation_data = json.features[0].properties.elevation;
        //Retrieve array of points from json file
        var coordinates = json.features[0].geometry.coordinates;
        //Calculate distances between points
        var distances = [];
        for (var i = 0; i < coordinates.length - 1; i++) {
            var j = i + 1;
            var x1 = coordinates[i][0]; //lon
            var y1 = coordinates[i][1]; //lat
            var x2 = coordinates[j][0]; //lon
            var y2 = coordinates[j][1]; //lat
            var d = getDistanceFromLatLonInKm(y1, x1, y2, x2);
            //var d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            distances.push(d);
        }

        //Calculate x y points to graph based on elevations and distances
        var data = [];
        var data_zero = [];
        var line_endpoints = [];
        var line_endpoints_zero = [];
        var curr_x = 0;
        var counter = 0;
        while (elevation_data.length > 0) {
            curr_y = elevation_data.shift();
            data.push([curr_x, curr_y, coordinates[counter][0], coordinates[counter][1]]);
            data_zero.push([curr_x, 0, coordinates[counter][0], coordinates[counter][1]]);
            counter++;
            curr_x = curr_x + distances.shift();
        }
        //Also calculate endpoints for lines connecting the points

        for (var i = 0; i < data.length - 1; i++) {
            var j = i + 1;
            line_endpoints.push([data[i][0], data[i][1], data[j][0], data[j][1]]);
            line_endpoints_zero.push([data[i][0], 0, data[j][0], 0]);
        }

        //Data to plot is now stored in `data`; begin plotting
        
        
        var w = document.getElementById("elevation-graph").offsetWidth;
        var h = document.getElementById("elevation-graph").offsetHeight;
        var padding = 50;
        var point_radius = 0.01;
        var lineFunction = d3.svg.line()
            .x(function(d) {
                return xScale(d[0]);
            })
            .y(function(d) {
                return yScale(d[1]);
            })
            .interpolate("cardinal");

        xScale = d3.scale.linear()
            .domain([0, d3.max(data, function(d) {
                return d[0];
            })])
            .range([padding, w - padding * 2]);
        yScale = d3.scale.linear()
            .domain([0, d3.max(data, function(d) {
                return d[1];
            })])
            .range([h - padding, padding]);
        var distances_scaled = [];
        var elevations_scaled = [];
        for (var i = 0; i<data.length; i++){
            distances_scaled.push(xScale(data[i][0]));
            elevations_scaled.push(yScale(data[i][1]));
        }
        console.log("distscaled");
        console.log(distances_scaled);
        var xAxis = d3.svg.axis()
            .scale(xScale)
            .orient("bottom")
            .ticks(5);
        var yAxis = d3.svg.axis()
            .scale(yScale)
            .orient("left")
            .ticks(2);
        svg = d3.select("#elevation-graph")
            .append("svg")
            .attr("width", w)
            .attr("height", h);


        svg.selectAll("circle")
            .data(data_zero)
            .enter()
            .append("circle")
            .attr("clip-path", "url(#chart-area)")
            .attr("id", function(d, i) {
                return "circle" + i;
            })
            .attr("cx", function(d) {
                return xScale(d[0]);
            })
            .attr("cy", function(d) {
                return yScale(d[1]);
            })
            .attr("r", point_radius)
            .attr("class", "point")
			.attr("class", "originalpoint")
            
        //X axis label
        svg.append("text")
            .attr("class", "xlabel")
            .attr("text-anchor", "end")
            .attr("x", w / 2 + 30)
            .attr("y", h - 30)
            .text("Distance (km)");
        svg.append("text")
            .attr("class", "ylabel")
            .attr("text-anchor", "middle")
            .attr("x", -h / 2)
            .attr("y", padding - 30)
            .attr("transform", "rotate(-90)")
            .text("Elevation (m)");
        svg.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(0," + (h - padding - 20) + ")")
            .call(xAxis);
        svg.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(" + padding + ",0)")
            .call(yAxis);
        lineGraph = svg.append("path")
            .attr("d", lineFunction(data))
            .attr("stroke", "blue")
            .attr("stroke-width", 5)
            .attr("id", "graphline")
            .attr("fill", "none");
        var totalLength = lineGraph.node().getTotalLength();
        lineGraph
            .attr("stroke-dasharray", totalLength + " " + totalLength)
            .attr("stroke-dashoffset", totalLength)
            .transition()
            .duration(2000)
            .ease("linear")
            .attr("stroke-dashoffset", 0);
        //Define clipping path
        svg.append("clipPath") //Make a new clipPath
            .attr("id", "chart-area") //Assign an ID
            .append("rect") //Within the clipPath, create a new rect
            .attr("x", padding - 10) //Set rect's position and sizeâ€¦
            .attr("y", padding - 20)
            .attr("width", w - padding * 2)
            .attr("height", h - padding * 2);
        svg.selectAll("#graphline").on('mouseout', function() {
            geoJsonLayer.clearLayers();
			drawBaseGeojson();
            
            //geoJsonLayer.addData(newjsonPoint);
              //  geoJsonLayer.addData(destinationPoint);
        });
		var previousinterpolatedpoint;
        svg.on('mouseout', function() {
            console.log("running svg mouseout");
            geoJsonLayer.clearLayers();
            drawBaseGeojson();
        });
        svg.on('mousemove', function() {
			//remove previous point, if it exists
			geoJsonLayer.clearLayers();
            drawBaseGeojson();
            var coordinates = [0, 0];
            coordinates = d3.mouse(this);
           
            console.log(coordinates);

            var neighborid = 0;
            svg.selectAll(".originalpoint").each(function(d, i) {
                var pointX = d3.select(this).attr("cx");

                if (pointX > coordinates[0]) {
                    return;
                }

                neighborid++;

            });

            //select the right neighbor and get its coordinates, both on the chart and geographically
            neighboridString = "#circle" + neighborid;

            var rightneighborCoords = [0, 0];
            var rightneighborGeoCoords = [0, 0];

            svg.selectAll(neighboridString).each(function(d, i) {
                rightneighborCoords = [d3.select(this).attr("cx"), d3.select(this).attr("cy")];
                rightneighborGeoCoords = [d[3], d[2]];
            });

            //repeat the process for the left neighbor
            neighboridString = "#circle" + (neighborid - 1);
            console.log("left neighbor id string is " + neighboridString);
            var leftneighborCoords = [0, 0];
            var leftneighborGeoCoords = [0, 0];
            svg.selectAll(neighboridString).each(function(d, i) {
                leftneighborCoords = [d3.select(this).attr("cx"), d3.select(this).attr("cy")];
                leftneighborGeoCoords = [d[3], d[2]];
            });

            //calculate distance between left neighbor and right neighbor on the graph
            var x1 = leftneighborCoords[0];
            var y1 = leftneighborCoords[1];
            var x2 = rightneighborCoords[0];
            var y2 = rightneighborCoords[1];
            var graphDistNeighbors = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            //calculate distance between mouse and left neighbor on the graph
            x2 = coordinates[0];
            //Assume the mouse is on the line
            var bisect = d3.bisector(function(d) {return d;});
            var bisect_index = bisect.right(distances_scaled, x2);
            y2 = elevations_scaled[bisect_index];
            var mouseToLeftNeighborDist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            //calculate mouse cursor's fractional position on line between left and right neighbor
            var mouseFractionPosition = mouseToLeftNeighborDist / graphDistNeighbors;

            //finally calculate the geographic coordinates this would correspond to
            //calculate distance between the geographic coordinates of left and right neighbor
            x1 = leftneighborGeoCoords[0];
            y1 = leftneighborGeoCoords[1];
            x2 = rightneighborGeoCoords[0];
            y2 = rightneighborGeoCoords[1];
            var geoNeighborsDistance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            //calculate distance to move from the left neighbor
            var distanceToMove = mouseFractionPosition * geoNeighborsDistance;
            var resultX = x1 + (distanceToMove / geoNeighborsDistance) * (x2 - x1);
            var resultY = y1 + (distanceToMove / geoNeighborsDistance) * (y2 - y1);
            //plot a new geojson point at this location

            var interpolatedPoint = [{
                "type": "Point",
                "coordinates": [resultY, resultX]
            }];
			previousinterpolatedpoint = interpolatedPoint;
            geoJsonLayer.addData(interpolatedPoint);
            //geoJsonLayer.addData(newjsonPoint);
            //geoJsonLayer.addData(destinationPoint);

        });
        svg.selectAll("circle")
            .data(data)
            .transition()
            .duration(1000)
            .delay(function(d, i) {
                return i * 50;
            })
            .attr("cy", function(d) {
                return yScale(d[1]);
            })
            /*
            lineGraph.attr("d", lineFunction(data))
            	.transition()
            	.duration(500)
            	.delay(5000);
            */
        linesvg = d3.select("body")
            .append("svg")
            .attr("width", window.innerWidth)
            .attr("height", window.innerHeight);


    
    //http://stackoverflow.com/questions/18883601/function-to-calculate-distance-between-two-coordinates-shows-wrong
function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
    var R = 6371; // Radius of the earth in km
    var dLat = deg2rad(lat2 - lat1); // deg2rad below
    var dLon = deg2rad(lon2 - lon1);
    var a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    var d = R * c; // Distance in km
    return d;
}
var highlightid = -1;

function unhighlightPoint() {
	
    svg.selectAll(".insertedpoint")
        .attr("r", 0.001);
		
}

function highlightPoint(mouselat, mouselng) {

    //find the IDs of the two closest neighbors
    var foundindexes = false;
    var index1 = 0;
    var index2 = 1;
    while (!foundindexes) {
        svg.selectAll("#circle" + index1).each(function(circle1data) {
            svg.selectAll("#circle" + index2).each(function(circle2data) {
                var circle1lat = circle1data[3];
                var circle1lng = circle1data[2];
                var circle2lat = circle2data[3];
                var circle2lng = circle2data[2];
                //check if the mouse lies between these two points
                var distBetweenPoints = Math.sqrt((circle2lat - circle1lat) * (circle2lat - circle1lat) + (circle2lng - circle1lng) * (circle2lng - circle1lng));
                var distMouse2c1 = Math.sqrt((mouselat - circle1lat) * (mouselat - circle1lat) + (mouselng - circle1lng) * (mouselng - circle1lng));
                var distMouse2c2 = Math.sqrt((circle2lat - mouselat) * (circle2lat - mouselat) + (circle2lng - mouselng) * (circle2lng - mouselng));
                var tolerance = 0.00005;
                if ((distMouse2c1 + distMouse2c2 > distBetweenPoints - tolerance) && (distMouse2c1 + distMouse2c2 < distBetweenPoints + tolerance)) {
                    foundindexes = true;
                }
            })
        });
        if (!foundindexes) {
            index1++;
            index2++;
        }
        //infinite loop protection
        if (index2 > 10000) {
            foundindexes = true;
            console.log("Error! Infinite loop.");
        }
    }
	console.log("neighbor ids");
	console.log(index1, index2);
	var neighbor1GeoCoords = [0, 0];
	var neighbor1GraphCoords = [0, 0];
	var neighbor2GeoCoords = [0, 0];
	var neighbor2GraphCoords = [0, 0];
	svg.selectAll("#circle"+index1).each(function(d){
		neighbor1GeoCoords = [d[3], d[2]];
		neighbor1GraphCoords = [d[0], d[1]];
	});
	svg.selectAll("#circle"+index2).each(function(d){
		neighbor2GeoCoords = [d[3], d[2]];
		neighbor2GraphCoords = [d[0], d[1]];
	});
	
	var x1 = neighbor1GeoCoords[0];
	var y1 = neighbor1GeoCoords[1];
	var x2 = neighbor2GeoCoords[0];
	var y2 = neighbor2GeoCoords[1];
	
	var geoDistNeighbors = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	x2 = mouselat;
	y2 = mouselng;
	console.log(x1, y1, x2, y2);
	var mouseToNeighbor1Dist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	var mouseFractionPosition = mouseToNeighbor1Dist / geoDistNeighbors;
	//calculate distance between the neighbors on the graph
	x1 = neighbor1GraphCoords[0];
	y1 = neighbor1GraphCoords[1];
	x2 = neighbor2GraphCoords[0];
	y2 = neighbor2GraphCoords[1];
	console.log("mouse fraction position");
	console.log(mouseFractionPosition);
	var neighborsDistOnGraph = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	var distanceToMove = mouseFractionPosition * neighborsDistOnGraph;
	
	var resultX = x1 + (distanceToMove / neighborsDistOnGraph) * (x2 - x1);
    var resultY = y1 + (distanceToMove / neighborsDistOnGraph) * (y2 - y1);
	
	var newcircle = svg.append("circle")
		.attr("class", "point")
		.attr("cx", xScale(resultX))
		.attr("cy", yScale(resultY))
		.attr("r", 6.5)
		.attr("class", "insertedpoint");
	
    console.log("Found placement location!");
	console.log(xScale(resultX), yScale(resultY));
	
	
    

}


function deg2rad(deg) {
    return deg * (Math.PI / 180)
}

function findNeighboringPoints(mouseX, mouseY) {
    //iterate through each point until the X value of each point is greater
    //than mouseX, return index of that point
    console.log("findneighboringpoints was called");
    var returnid = 0;
    svg.selectAll(".originalpoint").each(function(d, i) {
        var pointX = d3.select(this).attr("cx");

        if (pointX > mouseX) {
            console.log("returning " + returnid)
            return returnid;
        }

        returnid++;

    });
}
        </script>
    </div>
	
   
        
		
    
	<script>
    window.drawBaseGeojson = function(){
        geoJsonLayer = L.geoJson(freeBus, {
                    style: function (feature) {
                        try {
                        console.log("printing properties upper");
                         console.log(feature);
                        return feature.geometry.properties.style;
                        }
                        catch(err) {
                        return {"color":"#0000FF"};
                        }
                            
                    },
                    pointToLayer: function(feature, latlng) {
                        console.log("pointtolayer features");
                        console.log(feature);
                        try {
                            console.log("markertype");
                            console.log(feature.properties.markertype);
                            if (feature.properties.markertype == "greenmarker"){
                                return L.marker(latlng, {
                                    icon: startIcon
                                    
                                });
                            }
                            else if (feature.properties.markertype == "redmarker"){
                                return L.marker(latlng, {
                                    icon: endIcon
                                });
                            }
                            else {
                                console.log("using endicon");
                                return L.marker(latlng, {
                                    icon: pinIcon
                                });
                            }
                            
                        }
                        catch (err){
                        console.log("using endicon");
                            return L.marker(latlng, {
                                    icon: pinIcon
                                });
                        }
                        
                    },
                    onEachFeature: function(feature, layer) {
                        layer.on('mousemove', function(e) {
                            //If user hovers over the line on the map
                            //Get coordinates associated with hover pointer
                            var mouselat = e.latlng.lat;
                            var mouselng = e.latlng.lng;
                            //Get the point on the graph closest to the mouse location
							unhighlightPoint();
                            highlightPoint(mouselat, mouselng);


                        });
                        layer.on('mouseout', function(e) {
                            unhighlightPoint();

                        });
                    }

                }).addTo(map);
        //dashed lines from start marker to start of route and from end marker to end of route
        
        geoJsonLayer.addData(startPoint);
        geoJsonLayer.addData(destinationPoint);
        geoJsonLayer.addData(dashedLines);
        return geoJsonLayer;
    }
    var map = L.map('map').setView([{{centerlat}}, {{centerlng}}], {{defaultzoom}});
        L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
            attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
            maxZoom: 18,
            id: 'tlng05.8718d45a',
            accessToken: 'pk.eyJ1IjoidGxuZzA1IiwiYSI6Ijc0YWNlMGUyYjYzMjk4OWYyNTEzNTBkYmE1OTk2NjU3In0.0C0qnsoVHF1U7jrONokNZg'
        }).addTo(map);
        var geoJsonLayer = drawBaseGeojson();
        geoJsonLayer.addData(startPoint);
        geoJsonLayer.addData(destinationPoint);
	
	//console.log(result);
	function getCoordinates(address){
		var url = 'https://api.opencagedata.com/geocode/v1/json?q=';
		
		var addressEncoded = encodeURIComponent(address);
		url = url + addressEncoded + '&key=7945028e977fa9593e5b02378cbf0f27&pretty=1';
		var xmlHttp = new XMLHttpRequest();
		xmlHttp.open("GET", url, false);
		xmlHttp.send(null);
		return xmlHttp.responseText;
	}
    
	</script>
    {% if lat != 0 and lng != 0 and destlat != 0 and destlng != 0 %}
    <script language="javascript">
    //marker for start location
    var startPoint = [{
                "type": "Point",
                "properties": {"markertype": "greenmarker"},
                "coordinates": [{{ lng }}, {{lat}}]
            }];
    //marker for end location
    var destinationPoint = [{
                "type": "Point",
                "properties": {"markertype": "redmarker"},
                "coordinates": [{{ destlng }}, {{ destlat }}]
            }];
    var dashedLines = [{
    "type": "LineString",
    "properties": {"style": {"color":"#222222", "dashArray":"5,5"}},
    "coordinates": [[{{routestartlng}}, {{routestartlat}}], [{{lng}}, {{lat}}]]
    }, {
    "type": "LineString",
    "properties": {"style": {"color":"#222222", "dashArray":"5,10"}},

    "coordinates": [[{{routeendlng}}, {{routeendlat}}], [{{destlng}}, {{destlat}}]]
    }];
            geoJsonLayer.addData(startPoint);
            geoJsonLayer.addData(destinationPoint);
            geoJsonLayer.addData(dashedLines);
    </script>
    {% endif %}
    <div id="panel">
    {% if error_message %}
    {{ error_message }}
    {% endif %}
    <form action="/getroute/search" method="get">
      <input id="inputaddress" name="inputaddress" type="text" value="{{ start_textbox_value}}" onfocus="if(this.value == 'Enter start address') {this.value=''}" onblur="if(this.value == ''){this.value ='Enter start address'}">
      <input id="inputdest" name="inputdest" type="text" value="{{ dest_textbox_value }}" onfocus="if(this.value == 'Enter end address') {this.value=''}" onblur="if(this.value == ''){this.value ='Enter end address'}">
      <!--<input type="button" value="Search" onclick="codeAddress()">-->
      <input type="submit" value="Submit">
    </form>
    </div>
</body>

</html>