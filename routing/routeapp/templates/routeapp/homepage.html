<!DOCTYPE html>
<html lang="en">
{% load staticfiles %}
<head>
    <meta charset="utf-8" />
    <title>AccessRoute</title>
    <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.css" />
    <link rel="stylesheet" href="{% static 'routeapp/css/graph-style.css' %}" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    
    <script src="http://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js" charset="utf-8"></script>
    <link rel="stylesheet" href="{% static 'routeapp/leaflet.awesome-markers.css' %}">
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <link rel="shortcut icon" type="image/png" href="{% static 'routeapp/favicon.ico' %}"/>
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="{% static 'routeapp/leaflet.awesome-markers.js' %}"></script>
    
    <script language="javascript">
    //var construction_geojson = "{{constructionfeatures}}";
    var construction_geojson = {{constructionfeatures|safe}};
    var MarkerIcon = L.Icon.extend({
    options: {
        shadowUrl: "{% static 'routeapp/marker-shadow.png' %}",
        iconSize:     [38, 95],
        shadowSize:   [50, 64],
        iconAnchor:   [144, 467],
        shadowAnchor: [144, 467],
        popupAnchor:  [-3, -76]
    }
});
    //Icons for displaying markers on the map
    var startIcon = L.AwesomeMarkers.icon({
        prefix: 'fa', //font awesome rather than bootstrap
        markerColor: 'green', // see colors above
        icon: 'home' //http://fortawesome.github.io/Font-Awesome/icons/
    });
    var endIcon = L.AwesomeMarkers.icon({
        prefix: 'fa', //font awesome rather than bootstrap
        markerColor: 'red', // see colors above
        icon: 'flag-checkered' //http://fortawesome.github.io/Font-Awesome/icons/
    });
    var pinIcon = L.AwesomeMarkers.icon({
        prefix: 'fa', //font awesome rather than bootstrap
        markerColor: 'blue', // see colors above
        icon: 'map-pin' //http://fortawesome.github.io/Font-Awesome/icons/
    });
    var constructionIcon = L.AwesomeMarkers.icon({
        prefix: 'fa', //font awesome rather than bootstrap
        markerColor: 'orange', // see colors above
        icon: 'ban' //http://fortawesome.github.io/Font-Awesome/icons/
    });
    </script>
    
    <style type="text/css">
        #map {
            position: relative;
            height: 100%;
        }
        
        #elevation-graph {
            position: absolute;
            height: 30%;
            width: 100%;
            top: 70%;
            background: rgba(255,255,255,0.8);
            
        }
        
        html,
        body {
            height: 100%;
            margin: 0px;
            padding: 0px;
        }
		.dashedVerticalLine, .markercircle {
            pointer-events:none;
        }
		#panel {
        position: absolute;
        top: 5px;
        left: 180px;
        margin-left: -180px;
        z-index: 5;
        background-color: #fff;
        padding: 15px;
        border: 1px solid #999;
      }
      .container{
        max-width: 500px;
        
    }
    h3, button, input,select, textarea{
        font-family: 'Open Sans';
    }
.leaflet-popup-content {
width:auto !important;
}
      /*
      Provide the following styles for both ID and class,
      where ID represents an actual existing "panel" with
      JS bound to its name, and the class is just non-map
      content that may already have a different ID with
      JS bound to its name.
      */

      #panel, .panel {
        font-family: 'Roboto','sans-serif';
        line-height: 30px;
        padding-left: 20px;
      }

      #panel select, #panel input, .panel select, .panel input {
        font-size: 15px;
      }

      #panel select, .panel select {
        width: 100%;
      }

      #panel i, .panel i {
        font-size: 12px;
      }
      .glyphicon.spinning {
    animation: spin 1s infinite linear;
    -webkit-animation: spin2 1s infinite linear;
}

@keyframes spin {
    from { transform: scale(1) rotate(0deg); }
    to { transform: scale(1) rotate(360deg); }
}

@-webkit-keyframes spin2 {
    from { -webkit-transform: rotate(0deg); }
    to { -webkit-transform: rotate(360deg); }
}
.spinner {
  display: inline-block;
  opacity: 0;
  max-width: 0;

  -webkit-transition: opacity 0.25s, max-width 0.45s; 
  -moz-transition: opacity 0.25s, max-width 0.45s;
  -o-transition: opacity 0.25s, max-width 0.45s;
  transition: opacity 0.25s, max-width 0.45s; /* Duration fixed since we animate additional hidden width */
}

.has-spinner.active {
  cursor:progress;
}

.has-spinner.active .spinner {
  opacity: 1;
  max-width: 50px; /* More than it will ever come, notice that this affects on animation duration */
}
    </style>
	<script src="{% static 'routeapp/js/leaflet-knn.min.js' %}"></script>
</head>

<body>

    <div id="map"></div>
    <!--<script src="/getroute/route.geojson"></script>-->
    <script language="javascript">
    var freeBus = {{ routegeojson|safe }};
    </script>
    <script language="javascript">
    var jsondata = '{{elevationjson|safe}}';
    </script>
	<div id="elevation-graph" class="collapse">
        
        <!--<script src="{% static 'routeapp/js/elevation-graph.js' %}"></script>-->
        <script language="javascript">
        var preferredUnit = 'metric';
        var refreshGraph = function(){
            //remove the original svg
            d3.select("#grapharea").remove();
            d3.select(".grapharea").remove();
            document.getElementById("elevation-graph").innerHTML = "";
            //recalculate stuff
            var json = JSON.parse(jsondata);
            
            var linesvg;
            var xScale;
            var yScale;
            //Retrieve array of coordinates from json file
            var coordinates = json.features[0].geometry.coordinates;
            //Retrieve array containing elevation for each of the coordinates
            var elevation_data = json.features[0].properties.elevation;
            var distances = [];
            for (var i = 0; i < coordinates.length - 1; i++) {
                var j = i + 1;
                var x1 = coordinates[i][0]; //lon
                var y1 = coordinates[i][1]; //lat
                var x2 = coordinates[j][0]; //lon
                var y2 = coordinates[j][1]; //lat
                var d = getDistanceFromLatLonInKm(y1, x1, y2, x2);
                if(preferredUnit == 'imperial'){
                    d *= 0.621371
                }
                distances.push(d);
            }
            //Calculate points to graph based on elevations and distances
            //For each point, x = distance from start point
            //                y = elevation in meters
            var data = [];
            //The 'data' array will look like this:
            /*
            [
                [x, y, lng, lat]
                [x, y, lng, lat]
                ...
            ]
            */
            //Populate the 'data' array using the 'elevation_data' array and 'distances' array
            var curr_x = 0;
            var counter = 0;
            while (elevation_data.length > 0) {
                curr_y = elevation_data.shift();
                if(preferredUnit == 'imperial'){
                    curr_y *= 3.28084;
                }
                data.push([curr_x, curr_y, coordinates[counter][0], coordinates[counter][1]]);
                
                counter++;
                curr_x = curr_x + distances.shift();
            }
            var w=$(window).width();
            var h=$(window).height()*0.30;
            var padding = 100;
            var point_radius = 0.01;
            
            var lineFunction = d3.svg.line()
                .x(function(d) {
                    return xScale(d[0]);
                })
                .y(function(d) {
                    return yScale(d[1]);
                })
                .interpolate("basis");
            //Create scale functions
            xScale = d3.scale.linear()
                .domain([0, d3.max(data, function(d) {
                    return d[0];
                })])
                .range([padding, w - padding * 2]);
                
            yDomainMin = d3.min(data, function(d) {
                return d[1];
            });
            yDomainMax = d3.max(data, function(d) {
                return d[1];
            });
            yRange = yDomainMax - yDomainMin;
            yScale = d3.scale.linear()
                .domain([yDomainMin - 0.2*yRange, yDomainMax+0.2*yRange])
                .range([h - padding, padding]);
            
            /* Keep arrays of distances and elevations scaled using the above
            scale functions */
            var distances_scaled = [];
            var elevations_scaled = [];
            for (var i = 0; i<data.length; i++){
                distances_scaled.push(xScale(data[i][0]));
                elevations_scaled.push(yScale(data[i][1]));
            }
            
            // Generate axes
            var xAxis = d3.svg.axis()
                .scale(xScale)
                .orient("bottom")
                .ticks(10);
            var yAxis = d3.svg.axis()
                .scale(yScale)
                .orient("left")
                .ticks(2);
            
            // Add the graph svg to the elevation-graph div
            svg = d3.select("#elevation-graph")
                .append("svg")
                .attr("id","maingrapharea")
                .attr("width", w)
                .attr("height", h);

            // Plot the points on the graph
            svg.selectAll("circle")
                .data(data)
                .enter()
                .append("circle")
                .attr("clip-path", "url(#chart-area)")
                .attr("id", function(d, i) {
                    return "circle" + i;
                })
                .attr("cx", function(d) {
                    return xScale(d[0]);
                })
                .attr("cy", function(d) {
                    return yScale(d[1]);
                })
                .attr("r", point_radius)
                .attr("class", "point")
                .attr("class", "originalpoint")
                
            //X axis label text
            svg.append("text")
                .attr("class", "xlabel")
                .attr("text-anchor", "end")
                .attr("x", w / 2 + 30)
                .attr("y", h - 30)
                .style("font-size", "20px")
                .text("Distance (km)");
            //Y axis label text
            svg.append("text")
                .attr("class", "ylabel")
                .attr("text-anchor", "middle")
                .attr("x", -h / 2)
                .attr("y", padding - 30)
                .attr("transform", "rotate(-90)")
                .style("font-size", "20px")
                .text("Elevation (m)");
            //Add X and Y axes to SVG
            svg.append("g")
                .attr("class", "axis")
                .attr("transform", "translate(0," + (h - padding) + ")")
                .style("font-size", "20px")
                .call(xAxis);
            svg.append("g")
                .attr("class", "axis")
                .attr("transform", "translate(" + (padding) + ",0)")
                .style("font-size", "20px")
                .call(yAxis);
            //Draw line through the points
            lineGraph = svg.append("path")
                .attr("d", lineFunction(data))
                .attr("stroke", "blue")
                .attr("stroke-width", 5)
                .attr("id", "graphline")
                .attr("fill", "none");
            var totalLength = lineGraph.node().getTotalLength();
            lineGraph
                .attr("stroke-dasharray", totalLength + " " + totalLength)
                .attr("stroke-dashoffset", totalLength)
                .transition()
                .duration(2000)
                .ease("linear")
                .attr("stroke", "gray")
                .attr("stroke-dashoffset", 0);
                
            
            //Define clipping path
            /*
            svg.append("clipPath") //Make a new clipPath
                .attr("id", "chart-area") //Assign an ID
                .append("rect") //Within the clipPath, create a new rect
                .attr("x", padding - 10) //Set rect's position and sizeâ€¦
                .attr("y", padding - 20)
                .attr("width", w - padding * 2)
                .attr("height", h - padding * 2);
            */
            var previousinterpolatedpoint;
            svg.on('mouseout', function() {
                console.log("running svg mouseout");
                svg.selectAll(".dashedVerticalLine").remove();
                svg.selectAll(".markercircle").remove();
                geoJsonLayer.clearLayers();
                drawBaseGeojson();
            });
            //If the user moves the mouse over the graph, mark the corresponding location on the map.
            
            svg.on('mousemove', function() {
                //remove previous point, if it exists
                geoJsonLayer.clearLayers();
                drawBaseGeojson();
                var coordinates = [0, 0];
                coordinates = d3.mouse(this);
               
                console.log(coordinates);

                var neighborid = 0;
                svg.selectAll(".originalpoint").each(function(d, i) {
                    var pointX = d3.select(this).attr("cx");

                    if (pointX > coordinates[0]) {
                        return;
                    }

                    neighborid++;

                });

                //select the right neighbor and get its coordinates, both on the chart and geographically
                neighboridString = "#circle" + neighborid;

                var rightneighborCoords = [0, 0];
                var rightneighborGeoCoords = [0, 0];

                svg.selectAll(neighboridString).each(function(d, i) {
                    rightneighborCoords = [d3.select(this).attr("cx"), d3.select(this).attr("cy")];
                    rightneighborGeoCoords = [d[3], d[2]];
                });

                //repeat the process for the left neighbor
                neighboridString = "#circle" + (neighborid - 1);
                console.log("left neighbor id string is " + neighboridString);
                var leftneighborCoords = [0, 0];
                var leftneighborGeoCoords = [0, 0];
                svg.selectAll(neighboridString).each(function(d, i) {
                    leftneighborCoords = [d3.select(this).attr("cx"), d3.select(this).attr("cy")];
                    leftneighborGeoCoords = [d[3], d[2]];
                });

                //calculate distance between left neighbor and right neighbor on the graph
                var x1 = leftneighborCoords[0];
                var y1 = leftneighborCoords[1];
                var x2 = rightneighborCoords[0];
                var y2 = rightneighborCoords[1];
                var graphDistNeighbors = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                //calculate distance between mouse and left neighbor on the graph
                x2 = coordinates[0];
                //Assume the mouse is on the line
                var bisect = d3.bisector(function(d) {return d;});
                var bisect_index = bisect.right(distances_scaled, x2);
                y2 = elevations_scaled[bisect_index];
                var mouseToLeftNeighborDist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                //calculate mouse cursor's fractional position on line between left and right neighbor
                var mouseFractionPosition = mouseToLeftNeighborDist / graphDistNeighbors;

                //finally calculate the geographic coordinates this would correspond to
                //calculate distance between the geographic coordinates of left and right neighbor
                x1 = leftneighborGeoCoords[0];
                y1 = leftneighborGeoCoords[1];
                x2 = rightneighborGeoCoords[0];
                y2 = rightneighborGeoCoords[1];
                var geoNeighborsDistance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
                //calculate distance to move from the left neighbor
                var distanceToMove = mouseFractionPosition * geoNeighborsDistance;
                var resultX = x1 + (distanceToMove / geoNeighborsDistance) * (x2 - x1);
                var resultY = y1 + (distanceToMove / geoNeighborsDistance) * (y2 - y1);
                //plot a new geojson point at this location

                var interpolatedPoint = [{
                    "type": "Point",
                    "coordinates": [resultY, resultX]
                }];
                previousinterpolatedpoint = interpolatedPoint;
                geoJsonLayer.addData(interpolatedPoint);
                //geoJsonLayer.addData(newjsonPoint);
                //geoJsonLayer.addData(destinationPoint);
                
                //draw a dashed vertical line at the mouse position
                  
                
                
                svg.selectAll(".dashedVerticalLine").remove();
                svg.selectAll(".markercircle").remove();
                console.log(coordinates[0]);
                //the min coordinate is actually the max elevation
                var maxElevation = Math.min.apply(Math, elevations_scaled);
                
                
                var offsetLeft = document.getElementById("graphline").offsetLeft;
                var x = d3.event.pageX - padding;
                //Don't allow the vertical line to go beyond the line graph's left edge
                if(coordinates[0]<padding){
                    coordinates[0] = padding;
                    x = 0;
                }
                console.log("offsetleft is "+offsetLeft);
                console.log("x is "+x);
                
                var pathLength = lineGraph.node().getTotalLength();
                var beginning = x, end = pathLength, target;
                var accuracy=10;
                pathEl = lineGraph.node();
                for(i = x; i < pathLength; i+=accuracy){
                    var pos = pathEl.getPointAtLength(i);
                    if(pos.x >= x){
                        
                        break;
                    }
                }
                console.log("pos.x is "+pos.x);
                console.log("pos.y is "+pos.y);
                var dashedVerticalLine = svg.append("line")
                                            .attr("x1", coordinates[0])
                                            .attr("x2", coordinates[0])
                                            .attr("y1", pos.y)
                                            .attr("y2", yScale(yDomainMin-0.2*yRange))
                                            .attr("stroke-width", 2)
                                            .attr("stroke", "black")
                                            .style("stroke-dasharray",("3,3"))
                                            .attr("class", "dashedVerticalLine");
                                            
                                            
                var markerCircle = svg.append("circle")
                                      .attr("cx", coordinates[0])
                                      .attr("cy", pos.y)
                                      .attr("r", 6.5)
                                      .attr("class", "markercircle")
                                      .style("fill", "black")
                                      .attr("fill-opacity", 0.0)
                                      .style("color", "black");
            });
       
        }
        //Parse the geojson containing elevation data into variable 'json'
        var json = JSON.parse(jsondata);
        var svg;
        var linesvg;
        var xScale;
        var yScale;


        
        //Retrieve array of coordinates from json file
        var coordinates = json.features[0].geometry.coordinates;
        //Retrieve array containing elevation for each of the coordinates
        var elevation_data = json.features[0].properties.elevation;
        
        //We need to plot distance from start point vs elevation, not coordinate vs elevation, so...
        
        //Create an array that contains distances between consecutive points, in km
        var distances = [];
        for (var i = 0; i < coordinates.length - 1; i++) {
            var j = i + 1;
            var x1 = coordinates[i][0]; //lon
            var y1 = coordinates[i][1]; //lat
            var x2 = coordinates[j][0]; //lon
            var y2 = coordinates[j][1]; //lat
            var d = getDistanceFromLatLonInKm(y1, x1, y2, x2);
            
            distances.push(d);
        }

        //Calculate points to graph based on elevations and distances
        //For each point, x = distance from start point
        //                y = elevation in meters
        var data = [];
        //The 'data' array will look like this:
        /*
        [
            [x, y, lng, lat]
            [x, y, lng, lat]
            ...
        ]
        */
        
        //Populate the 'data' array using the 'elevation_data' array and 'distances' array
        var curr_x = 0;
        var counter = 0;
        while (elevation_data.length > 0) {
            curr_y = elevation_data.shift();
            data.push([curr_x, curr_y, coordinates[counter][0], coordinates[counter][1]]);
            
            counter++;
            curr_x = curr_x + distances.shift();
        }
        

        //Data to plot is now stored in `data`; begin plotting
        
        
        //var w = document.getElementById("elevation-graph").offsetWidth;
        //var h = document.getElementById("elevation-graph").offsetHeight;
        var w=$(document).width();
        var h=$(document).height()*0.30;
        var padding = 100;
        var point_radius = 0.01;
        
        var lineFunction = d3.svg.line()
            .x(function(d) {
                return xScale(d[0]);
            })
            .y(function(d) {
                return yScale(d[1]);
            })
            .interpolate("basis");
        //Create scale functions
        xScale = d3.scale.linear()
            .domain([0, d3.max(data, function(d) {
                return d[0];
            })])
            .range([padding, w - padding * 2]);
            
        yDomainMin = d3.min(data, function(d) {
            return d[1];
        });
        yDomainMax = d3.max(data, function(d) {
            return d[1];
        });
        yRange = yDomainMax - yDomainMin;
        yScale = d3.scale.linear()
            .domain([yDomainMin - 0.2*yRange, yDomainMax+0.2*yRange])
            .range([h - padding, padding]);
        
        /* Keep arrays of distances and elevations scaled using the above
        scale functions */
        var distances_scaled = [];
        var elevations_scaled = [];
        for (var i = 0; i<data.length; i++){
            distances_scaled.push(xScale(data[i][0]));
            elevations_scaled.push(yScale(data[i][1]));
        }
        
        // Generate axes
        var xAxis = d3.svg.axis()
            .scale(xScale)
            .orient("bottom")
            .ticks(10);
        var yAxis = d3.svg.axis()
            .scale(yScale)
            .orient("left")
            .ticks(2);
        
        // Add the graph svg to the elevation-graph div
        svg = d3.select("#elevation-graph")
            .append("svg")
            .attr("id","grapharea")
            .attr("width", w)
            .attr("height", h);

        // Plot the points on the graph
        svg.selectAll("circle")
            .data(data)
            .enter()
            .append("circle")
            .attr("clip-path", "url(#chart-area)")
            .attr("id", function(d, i) {
                return "circle" + i;
            })
            .attr("cx", function(d) {
                return xScale(d[0]);
            })
            .attr("cy", function(d) {
                return yScale(d[1]);
            })
            .attr("r", point_radius)
            .attr("class", "point")
			.attr("class", "originalpoint")
            
        //X axis label text
        svg.append("text")
            .attr("class", "xlabel")
            .attr("text-anchor", "end")
            .attr("x", w / 2 + 30)
            .attr("y", h - 30)
            .style("font-size", "20px")
            .text("Distance (km)");
        //Y axis label text
        svg.append("text")
            .attr("class", "ylabel")
            .attr("text-anchor", "middle")
            .attr("x", -h / 2)
            .attr("y", padding - 30)
            .attr("transform", "rotate(-90)")
            .style("font-size", "20px")
            .text("Elevation (m)");
        //Add X and Y axes to SVG
        svg.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(0," + (h - padding) + ")")
            .style("font-size", "20px")
            .call(xAxis);
        svg.append("g")
            .attr("class", "axis")
            .attr("transform", "translate(" + (padding) + ",0)")
            .style("font-size", "20px")
            .call(yAxis);
        //Draw line through the points
        lineGraph = svg.append("path")
            .attr("d", lineFunction(data))
            .attr("stroke", "blue")
            .attr("stroke-width", 5)
            .attr("id", "graphline")
            .attr("fill", "none");
        var totalLength = lineGraph.node().getTotalLength();
        lineGraph
            .attr("stroke-dasharray", totalLength + " " + totalLength)
            .attr("stroke-dashoffset", totalLength)
            .transition()
            .duration(2000)
            .ease("linear")
            .attr("stroke", "gray")
            .attr("stroke-dashoffset", 0);
            
        
        //Define clipping path
        /*
        svg.append("clipPath") //Make a new clipPath
            .attr("id", "chart-area") //Assign an ID
            .append("rect") //Within the clipPath, create a new rect
            .attr("x", padding - 10) //Set rect's position and sizeâ€¦
            .attr("y", padding - 20)
            .attr("width", w - padding * 2)
            .attr("height", h - padding * 2);
        */
		var previousinterpolatedpoint;
        svg.on('mouseout', function() {
            console.log("running svg mouseout");
            svg.selectAll(".dashedVerticalLine").remove();
            svg.selectAll(".markercircle").remove();
            geoJsonLayer.clearLayers();
            drawBaseGeojson();
        });
        //If the user moves the mouse over the graph, mark the corresponding location on the map.
        
        svg.on('mousemove', function() {
			//remove previous point, if it exists
			geoJsonLayer.clearLayers();
            drawBaseGeojson();
            var coordinates = [0, 0];
            coordinates = d3.mouse(this);
           
            console.log(coordinates);

            var neighborid = 0;
            svg.selectAll(".originalpoint").each(function(d, i) {
                var pointX = d3.select(this).attr("cx");

                if (pointX > coordinates[0]) {
                    return;
                }

                neighborid++;

            });

            //select the right neighbor and get its coordinates, both on the chart and geographically
            neighboridString = "#circle" + neighborid;

            var rightneighborCoords = [0, 0];
            var rightneighborGeoCoords = [0, 0];

            svg.selectAll(neighboridString).each(function(d, i) {
                rightneighborCoords = [d3.select(this).attr("cx"), d3.select(this).attr("cy")];
                rightneighborGeoCoords = [d[3], d[2]];
            });

            //repeat the process for the left neighbor
            neighboridString = "#circle" + (neighborid - 1);
            console.log("left neighbor id string is " + neighboridString);
            var leftneighborCoords = [0, 0];
            var leftneighborGeoCoords = [0, 0];
            svg.selectAll(neighboridString).each(function(d, i) {
                leftneighborCoords = [d3.select(this).attr("cx"), d3.select(this).attr("cy")];
                leftneighborGeoCoords = [d[3], d[2]];
            });

            //calculate distance between left neighbor and right neighbor on the graph
            var x1 = leftneighborCoords[0];
            var y1 = leftneighborCoords[1];
            var x2 = rightneighborCoords[0];
            var y2 = rightneighborCoords[1];
            var graphDistNeighbors = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            //calculate distance between mouse and left neighbor on the graph
            x2 = coordinates[0];
            //Assume the mouse is on the line
            var bisect = d3.bisector(function(d) {return d;});
            var bisect_index = bisect.right(distances_scaled, x2);
            y2 = elevations_scaled[bisect_index];
            var mouseToLeftNeighborDist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            //calculate mouse cursor's fractional position on line between left and right neighbor
            var mouseFractionPosition = mouseToLeftNeighborDist / graphDistNeighbors;

            //finally calculate the geographic coordinates this would correspond to
            //calculate distance between the geographic coordinates of left and right neighbor
            x1 = leftneighborGeoCoords[0];
            y1 = leftneighborGeoCoords[1];
            x2 = rightneighborGeoCoords[0];
            y2 = rightneighborGeoCoords[1];
            var geoNeighborsDistance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            //calculate distance to move from the left neighbor
            var distanceToMove = mouseFractionPosition * geoNeighborsDistance;
            var resultX = x1 + (distanceToMove / geoNeighborsDistance) * (x2 - x1);
            var resultY = y1 + (distanceToMove / geoNeighborsDistance) * (y2 - y1);
            //plot a new geojson point at this location

            var interpolatedPoint = [{
                "type": "Point",
                "coordinates": [resultY, resultX]
            }];
			previousinterpolatedpoint = interpolatedPoint;
            geoJsonLayer.addData(interpolatedPoint);
            //geoJsonLayer.addData(newjsonPoint);
            //geoJsonLayer.addData(destinationPoint);
            
            //draw a dashed vertical line at the mouse position
              
            
            
            svg.selectAll(".dashedVerticalLine").remove();
            svg.selectAll(".markercircle").remove();
            console.log(coordinates[0]);
            //the min coordinate is actually the max elevation
            var maxElevation = Math.min.apply(Math, elevations_scaled);
            
            
            var offsetLeft = document.getElementById("graphline").offsetLeft;
            var x = d3.event.pageX - padding;
            //Don't allow the vertical line to go beyond the line graph's left edge
            if(coordinates[0]<padding){
                coordinates[0] = padding;
                x = 0;
            }
            console.log("offsetleft is "+offsetLeft);
            console.log("x is "+x);
            
            var pathLength = lineGraph.node().getTotalLength();
            var beginning = x, end = pathLength, target;
            var accuracy=10;
            pathEl = lineGraph.node();
            for(i = x; i < pathLength; i+=accuracy){
                var pos = pathEl.getPointAtLength(i);
                if(pos.x >= x){
                    
                    break;
                }
            }
            console.log("pos.x is "+pos.x);
            console.log("pos.y is "+pos.y);
            var dashedVerticalLine = svg.append("line")
                                        .attr("x1", coordinates[0])
                                        .attr("x2", coordinates[0])
                                        .attr("y1", pos.y)
                                        .attr("y2", yScale(yDomainMin-0.2*yRange))
                                        .attr("stroke-width", 2)
                                        .attr("stroke", "black")
                                        .style("stroke-dasharray",("3,3"))
                                        .attr("class", "dashedVerticalLine");
                                        
                                        
            var markerCircle = svg.append("circle")
                                  .attr("cx", coordinates[0])
                                  .attr("cy", pos.y)
                                  .attr("r", 6.5)
                                  .attr("class", "markercircle")
                                  .style("fill", "black")
                                  .attr("fill-opacity", 0.0)
                                  .style("color", "black");
        });
       
    //http://stackoverflow.com/questions/18883601/function-to-calculate-distance-between-two-coordinates-shows-wrong
function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
    var R = 6371; // Radius of the earth in km
    var dLat = deg2rad(lat2 - lat1); // deg2rad below
    var dLon = deg2rad(lon2 - lon1);
    var a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    var d = R * c; // Distance in km
    return d;
}
var highlightid = -1;

function unhighlightPoint() {
	
    svg.selectAll(".insertedpoint")
        .attr("r", 6.5);
		
}

function highlightPoint(mouselat, mouselng) {
/*  This function is called when the user hovers the mouse over the route
    on the map. It draws a circle around the corresponding location on the
    elevation graph, interpolating if necessary. */
    
    //find the IDs of the two closest neighbors
    var foundindexes = false;
    var index1 = 0;
    var index2 = 1;
    while (!foundindexes) {
        svg.selectAll("#circle" + index1).each(function(circle1data) {
            svg.selectAll("#circle" + index2).each(function(circle2data) {
                var circle1lat = circle1data[3];
                var circle1lng = circle1data[2];
                var circle2lat = circle2data[3];
                var circle2lng = circle2data[2];
                //check if the mouse lies between these two points
                var distBetweenPoints = Math.sqrt((circle2lat - circle1lat) * (circle2lat - circle1lat) + (circle2lng - circle1lng) * (circle2lng - circle1lng));
                var distMouse2c1 = Math.sqrt((mouselat - circle1lat) * (mouselat - circle1lat) + (mouselng - circle1lng) * (mouselng - circle1lng));
                var distMouse2c2 = Math.sqrt((circle2lat - mouselat) * (circle2lat - mouselat) + (circle2lng - mouselng) * (circle2lng - mouselng));
                var tolerance = 0.00005;
                if ((distMouse2c1 + distMouse2c2 > distBetweenPoints - tolerance) && (distMouse2c1 + distMouse2c2 < distBetweenPoints + tolerance)) {
                    foundindexes = true;
                }
            })
        });
        if (!foundindexes) {
            index1++;
            index2++;
        }
        //infinite loop protection
        if (index2 > 10000) {
            foundindexes = true;
            console.log("Error! Infinite loop.");
        }
    }
	console.log("neighbor ids");
	console.log(index1, index2);
	var neighbor1GeoCoords = [0, 0];
	var neighbor1GraphCoords = [0, 0];
	var neighbor2GeoCoords = [0, 0];
	var neighbor2GraphCoords = [0, 0];
	svg.selectAll("#circle"+index1).each(function(d){
		neighbor1GeoCoords = [d[3], d[2]];
		neighbor1GraphCoords = [d[0], d[1]];
	});
	svg.selectAll("#circle"+index2).each(function(d){
		neighbor2GeoCoords = [d[3], d[2]];
		neighbor2GraphCoords = [d[0], d[1]];
	});
	
	var x1 = neighbor1GeoCoords[0];
	var y1 = neighbor1GeoCoords[1];
	var x2 = neighbor2GeoCoords[0];
	var y2 = neighbor2GeoCoords[1];
	
	var geoDistNeighbors = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	x2 = mouselat;
	y2 = mouselng;
	console.log(x1, y1, x2, y2);
	var mouseToNeighbor1Dist = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	var mouseFractionPosition = mouseToNeighbor1Dist / geoDistNeighbors;
	//calculate distance between the neighbors on the graph
	x1 = neighbor1GraphCoords[0];
	y1 = neighbor1GraphCoords[1];
	x2 = neighbor2GraphCoords[0];
	y2 = neighbor2GraphCoords[1];
	console.log("mouse fraction position");
	console.log(mouseFractionPosition);
	var neighborsDistOnGraph = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	var distanceToMove = mouseFractionPosition * neighborsDistOnGraph;
	
	var resultX = x1 + (distanceToMove / neighborsDistOnGraph) * (x2 - x1);
    var resultY = y1 + (distanceToMove / neighborsDistOnGraph) * (y2 - y1);
	
	var newcircle = svg.append("circle")
		.attr("class", "point")
		.attr("cx", xScale(resultX))
		.attr("cy", yScale(resultY))
		.attr("r", 0.01)
        
		.attr("class", "insertedpoint");
	//Draw a dashed vertical line
    svg.selectAll(".dashedVerticalLine").remove();
    svg.selectAll(".markercircle").remove();
    var verticalLineX;
    if (xScale(resultX)<padding){
        verticalLineX = padding;
    }
    else{
        verticalLineX = xScale(resultX);
    }
    
    var dashedVerticalLine = svg.append("line")
                                        .attr("x1", xScale(resultX))
                                        .attr("x2", xScale(resultX))
                                        .attr("y1", yScale(resultY))
                                        .attr("y2", yScale(yDomainMin - 0.2*yRange))
                                        .attr("stroke-width", 2)
                                        .attr("stroke", "black")
                                        .style("stroke-dasharray",("3,3"))
                                        .attr("class", "dashedVerticalLine");

}

$(window).resize(function() {
    refreshGraph();
});

function deg2rad(deg) {
    return deg * (Math.PI / 180)
}

function findNeighboringPoints(mouseX, mouseY) {
    //iterate through each point until the X value of each point is greater
    //than mouseX, return index of that point
    console.log("findneighboringpoints was called");
    var returnid = 0;
    svg.selectAll(".originalpoint").each(function(d, i) {
        var pointX = d3.select(this).attr("cx");

        if (pointX > mouseX) {
            console.log("returning " + returnid)
            return returnid;
        }

        returnid++;

    });
}
        </script>
    </div>
	
   
        
		
    
	<script>
    window.drawBaseGeojson = function(){
        geoJsonLayer = L.geoJson(freeBus, {
                    style: function (feature) {
                        try {
                        console.log("printing properties upper");
                        console.log(feature);
                        return feature.geometry.properties.style;
                        }
                        catch(err) {
                        return {"color":"#0000FF", "stroke-width":20};
                        }
                            
                    },
                    pointToLayer: function(feature, latlng) {
                        console.log("pointtolayer features");
                        console.log(feature);
                        try {
                            console.log("markertype");
                            console.log(feature.properties.markertype);
                            if (feature.properties.markertype == "greenmarker"){
                                return L.marker(latlng, {
                                    icon: startIcon
                                    
                                });
                            }
                            else if (feature.properties.markertype == "redmarker"){
                                return L.marker(latlng, {
                                    icon: endIcon
                                });
                            }
                            else if (feature.properties.markertype == "construction"){
                                return L.marker(latlng, {
                                    icon: constructionIcon
                                });
                            }
                            else {
                                console.log("using endicon");
                                return L.marker(latlng, {
                                    icon: pinIcon
                                });
                            }
                            
                        }
                        catch (err){
                        console.log("using endicon");
                            
                            return L.marker(latlng, {
                                    icon: pinIcon
                                });
                        }
                        
                    },
                    onEachFeature: function(feature, layer) {
                        layer.on('mousemove', function(e) {
                            //If user hovers over the line on the map
                            //Get coordinates associated with hover pointer
                            var mouselat = e.latlng.lat;
                            var mouselng = e.latlng.lng;
                            //Get the point on the graph closest to the mouse location
							unhighlightPoint();
                            highlightPoint(mouselat, mouselng);


                        });
                        layer.on('mouseout', function(e) {
                            svg.selectAll(".dashedVerticalLine").remove();
                            svg.selectAll(".markercircle").remove();
                            unhighlightPoint();

                        });
                        if (feature.properties && feature.properties.popupContent) {
                            layer.bindPopup(feature.properties.popupContent);
                            layer.on('mouseover', function (e) {
                                this.openPopup();
                            });
                            
                        }
                    }

                }).addTo(map);
        //dashed lines from start marker to start of route and from end marker to end of route
        
        geoJsonLayer.addData(startPoint);
        geoJsonLayer.addData(destinationPoint);
        geoJsonLayer.addData(dashedLines);
        //console.log(construction_geojson);
        //console.log(dashedLines);
        
        geoJsonLayer.addData(construction_geojson);
        return geoJsonLayer;
    }
    var map = L.map('map', {zoomControl: false}).setView([{{centerlat}}, {{centerlng}}], {{defaultzoom}});
        L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {
            attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, <a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, Imagery © <a href="http://mapbox.com">Mapbox</a>',
            maxZoom: 18,
            
            id: 'tlng05.8718d45a',
            accessToken: 'pk.eyJ1IjoidGxuZzA1IiwiYSI6Ijc0YWNlMGUyYjYzMjk4OWYyNTEzNTBkYmE1OTk2NjU3In0.0C0qnsoVHF1U7jrONokNZg'
        }).addTo(map);
        new L.Control.Zoom({position: 'topright'}).addTo(map);
        var geoJsonLayer = drawBaseGeojson();
        geoJsonLayer.addData(startPoint);
        geoJsonLayer.addData(destinationPoint);
	
	//console.log(result);
	function getCoordinates(address){
		var url = 'https://api.opencagedata.com/geocode/v1/json?q=';
		
		var addressEncoded = encodeURIComponent(address);
		url = url + addressEncoded + '&key=7945028e977fa9593e5b02378cbf0f27&pretty=1';
		var xmlHttp = new XMLHttpRequest();
		xmlHttp.open("GET", url, false);
		xmlHttp.send(null);
		return xmlHttp.responseText;
	}
    
	</script>
    {% if lat != 0 and lng != 0 and destlat != 0 and destlng != 0 %}
    <script language="javascript">
    //marker for start location
    var startPoint = [{
                "type": "Point",
                "properties": {"markertype": "greenmarker"},
                "coordinates": [{{ lng }}, {{lat}}]
            }];
    //marker for end location
    var destinationPoint = [{
                "type": "Point",
                "properties": {"markertype": "redmarker", "popupContent":"<a target='_blank' href='http://maps.google.com/?cbll={{destlat}},{{destlng}}&cbp=12,235,,0,5&layer=c'><img src='https://maps.googleapis.com/maps/api/streetview?size=200x200&location={{destlat}},{{destlng}}&fov=90&heading=235&pitch=10' /></a>"},
                "coordinates": [{{ destlng }}, {{ destlat }}]
            }];
    var dashedLines = [{
    "type": "LineString",
    "properties": {"style": {"color":"#222222", "dashArray":"5,5"}},
    "coordinates": [[{{routestartlng}}, {{routestartlat}}], [{{lng}}, {{lat}}]]
    }, {
    "type": "LineString",
    "properties": {"style": {"color":"#222222", "dashArray":"5,10"}},

    "coordinates": [[{{routeendlng}}, {{routeendlat}}], [{{destlng}}, {{destlat}}]]
    }];
            geoJsonLayer.addData(startPoint);
            geoJsonLayer.addData(destinationPoint);
            geoJsonLayer.addData(dashedLines);
            geoJsonLayer.addData(construction_geojson);
            
    function show_spinner(){
        $(loadingspinner).show(250);
    }
    </script>
    {% endif %}
    <div id="panel" class="container">
    <h3>Calculate accessible route</h3>
    {% if error_message %}
    {{ error_message }}
    {% endif %}
    <form action="/getroute/search" method="get" role="form">
    <div class="form-group">
        <!--<label for="text">Enter start point</label>-->
        <input type="text" class="form-control" id="startaddress" name="inputaddress" placeholder="Enter start address" {% if submitted_start %} value="{{submitted_start}}" {% endif %}>
    </div>
    <div class="form-group">
        <!--<label for="text">Enter destination</label>-->
        <input type="text" class="form-control" id="endaddress" name="inputdest" placeholder="Enter destination" {% if submitted_dest %} value="{{submitted_dest}}" {% endif %}>
    </div>
    <button type="submit" class="btn btn-primary has-spinner" onclick="show_spinner()">Navigate
        <span id="loadingspinner" style="display:none">
        &nbsp;&nbsp;<span class="glyphicon glyphicon-refresh spinning"></span>&nbsp;&nbsp;Loading, please be patient...
        </span>
    </button>
    <!--
      <input id="inputaddress" name="inputaddress" type="text" value="{{ start_textbox_value}}" onfocus="if(this.value == 'Enter start address') {this.value=''}" onblur="if(this.value == ''){this.value ='Enter start address'}">
      <input id="inputdest" name="inputdest" type="text" value="{{ dest_textbox_value }}" onfocus="if(this.value == 'Enter end address') {this.value=''}" onblur="if(this.value == ''){this.value ='Enter end address'}">
      
      <input type="submit" value="Submit">
    -->
    
    </form>
    <br>
    <button class="btn" data-toggle="collapse" data-target="#elevation-graph">Toggle elevation
    
    </button>
    </div>
</body>

</html>